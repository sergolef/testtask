<?php/** * Implements hook_entity_insert($entity, $type). */function loger_entity_insert($entity, $type) {    $event = 'insert';    _log_insert($type, $entity, $event);}/** *  Implements hook_entity_update($entity, $type) */function loger_entity_update($entity, $type) {    $event = 'update';    _log_insert($type, $entity, $event);}/** *  Implements hook_entity_load($entities, $type) */function loger_entity_load($entities, $type) {    $event = 'load';    _log_insert($type, $entities, $event);}/** *  Implements hook_entity_delete($entity, $type) */function loger_entity_delete($entity, $type) {    $event = 'delete';    _log_insert($type, $entity, $event);}/** *  Implements function for db_insert logs */function _log_insert($type, $entity, $event) {    $entityArr = explode(',', variable_get('entity_for_logging'));    if (in_array($type, $entityArr)) {        $desc = "";        if (is_array($entity)) {            $desc = $event . " group of entityes by type " . $type;        }        else {            $desc = $event . " entity by id: " . $entity->carid . " and type:" . $type;        }        $nid = db_insert('crudlogs') // Table name no longer needs {}            ->fields(array(              'description' => $desc,              'shared' => 0,              'date' => time(),            ))            ->execute();    }}/** *  IMplements hook_menu()  */function loger_menu() {    $items = array();    $items['admin/config/system/loger'] = array(      'title' => 'Loger',      'description' => 'Configure the Loger.',      'page callback' => 'drupal_get_form',      'page arguments' => array('loger_settings'),      'access callback' => 'user_access',      'access arguments' => array('administer site configuration'),    );    return $items;}function loger_settings() {    $form['entity_for_logging'] = array(      '#title' => t('Entity types'),      '#description' => t('Entitys should be separated by commas'),      '#type' => 'textfield',      '#default_value' => variable_get('entity_for_logging', ''),    );    $form['loger_enabled'] = array(      '#title' => t('Loger status'),      '#description' => t(''),      '#type' => 'checkbox',      '#default_value' => variable_get('loger_enabled', ''),    );    $form['twitter'] = array(      '#title' => t('Twitter settings'),      '#weight' => 5,      '#type' => 'fieldset',    );    $form['twitter']['twitter_consumer_key'] = array(      '#title' => t('Consumer key'),      '#description' => t(''),      '#type' => 'textfield',      '#default_value' => variable_get('twitter_consumer_key', ''),    );    $form['twitter']['twitter_consumer_secret'] = array(      '#title' => t('Consumer secret'),      '#description' => t(''),      '#type' => 'textfield',      '#default_value' => variable_get('twitter_consumer_secret', ''),    );    $form['twitter']['twitter_user_token'] = array(      '#title' => t('Access token'),      '#description' => t(''),      '#type' => 'textfield',      '#default_value' => variable_get('twitter_user_token', ''),    );    $form['twitter']['twitter_user_secret'] = array(      '#title' => t('Access token secret'),      '#description' => t(''),      '#type' => 'textfield',      '#default_value' => variable_get('twitter_user_secret', ''),    );    return system_settings_form($form);}/** * hook_cron_queue_info() */function loger_cron_queue_info() {    $queues['log'] = array(      'worker callback' => '_share_logs',      'time' => 60,    );    return $queues;}/** *  Implements callback function for crontab */function _share_logs($item) {    $message = $item->description . '[' . date("Y-m-d H:i:s", $item->date) . ']';    $logid = $item->logid;    set_status($message);}/** * Implements function for update shared status on {crudlog} tbl * @param $log_id * @return bool true or false */function _upadate_log_share_status($log_id) {    if (empty($log_id)) {        return false;    }    $num_updated = db_update('crudlogs') // Table name no longer needs {}        ->fields(array('shared' => 1,))        ->condition('logid', $log_id)        ->execute();    return true;}/** * Implements hook_cron() */function loger_cron() {    if (variable_get('loger_enabled', 0)) {        $result = db_query('SELECT * FROM {crudlogs} WHERE  date < :rtime AND shared = :status', array(          ':rtime' => REQUEST_TIME,          ':status' => 0,            ));        $queue = DrupalQueue::get('log');        foreach ($result as $log) {            $queue->createItem($log);        }    }}function _create_twitter_lib_obj() {    $consumer_key = variable_get('twitter_consumer_key', '');    $consumer_secret = variable_get('twitter_consumer_secret', '');    $user_token = variable_get('twitter_user_token', '');    $user_secret = variable_get('twitter_user_secret', '');    $tmhOAuth = new tmhOAuth(array(          'consumer_key' => $consumer_key,          'consumer_secret' => $consumer_secret,          'user_token' => $user_token,          'user_secret' => $user_secret,        ));    return $tmhOAuth;}function set_status($message) {    $tmhOAuth = _create_twitter_lib_obj();    $message_array = _prepare_status($message);    foreach ($message_array as $twit) {        $code = $tmhOAuth->request('POST', $tmhOAuth->url('1/statuses/update'), array(          'status' => $twit            ));        drupal_set_message($code);        if ($code == 200) {            tmhUtilities::pr(json_decode($tmhOAuth->response['response']));        }        else {            tmhUtilities::pr($tmhOAuth->response['response']);        }    }}function _prepare_status($str_message) {    $message_array = array();    if (empty($str_message) || $str_message == "") {        return false;    }    if (strlen($str_message) < 140) {        $message_array[] = $str_message;    }    else {        while (strlen($str_message) > 140) {            $msg = substr($str_message, 0, 140);            $str_message = substr($str_message, 140);            $message_array[] = $msg;            unset($msg);        }    }    return $message_array;}